module FSM(Clock, Reset, Address, ReadEnable, WriteEnable, Load, Clear, Transfer, Ready);
   input Clock,
   input Reset,
	//
   output wire [4:0]  Address,
   output reg         ReadEnable,
   output reg         WriteEnable,
   //
   output reg         Load,
   output reg         Clear,  
   output reg         Transfer,
   //
   output reg         Ready
	
   localparam INICIO       = 4'd0;
   localparam SOLICITA_MEM = 4'd1;
   localparam IDLE_1       = 4'd2;
   localparam LOAD         = 4'd3;
   localparam ADD          = 4'd4;
   localparam ADDING       = 4'd5;
   localparam SAVING       = 4'd6;
   localparam IDLE_2       = 4'd7;
   localparam END_STATE    = 4'd8;

   reg [3:0] state;
    
   reg [5:0] i; // (precisa ir até 32, então 6 bits)

   // O endereço de saída é sempre os 5 bits menos significativos de i
   assign Address = i[4:0];

   // ---------------------------------------------------------
   // 2. Lógica Sequencial (Transição de Estados e Contador)
   // ---------------------------------------------------------
   always @(posedge Clock or posedge Reset) begin
      if (Reset) begin
           state <= INICIO;
           i <= 6'd0;
      end
		else begin
			case (state)
				INICIO: begin
					i <= 6'd0; // i = 0
						state <= SOLICITA_MEM;
				end

				SOLICITA_MEM: begin
					state <= IDLE_1;
				end

				IDLE_1: begin
					state <= LOAD;
				end

				LOAD: begin
					state <= ADD;
				end

				ADD: begin
					// Ação: i = i + 1
					i <= i + 1'b1; 
                    
					// Lógica de transição baseada no NOVO valor de i (next_i)
					// Se i era 6, vira 7 (binário ...111).
					// Se i era 0, vira 1.
					if ((i + 1'b1) & 6'b000111 == 3'b111) begin
							// Se final 7 (7, 15, 23...), vai salvar
							state <= SAVING; 
					end else begin
							state <= ADDING;
					end
                    
					/* Nota: No diagrama, a verificação 'Address == 7' sai do ADD. 
						Como estamos atualizando i aqui, a verificação (i+1) garante 
						que vamos salvar no endereço 7 logo após ler o 6. */
				end

				ADDING: begin
					state <= SOLICITA_MEM;
				end

				SAVING: begin
					state <= IDLE_2;
				end

				IDLE_2: begin
					i <= i + 1'b1; // i = i + 1 (Pula o endereço onde salvou)
                    
					// Se i virou 32 (após salvar no 31 e incrementar), acabou.
					if ((i + 1'b1) == 6'd32) 
							state <= END_STATE;
					else 
							state <= SOLICITA_MEM;
					end

				END_STATE: begin
					state <= INICIO; // Reinicia após terminar
				end
                
				default: state <= INICIO;
			endcase
		end
	end

	// ---------------------------------------------------------
	// 3. Lógica de Saída (Combinacional)
   // ---------------------------------------------------------
	always @(*) begin
		// Valores Default (conforme diagrama)
		Clear       = 1'b1; // Ativo baixo, então 1 é "não resetar"
		ReadEnable  = 1'b0;
		WriteEnable = 1'b0;
		Load        = 1'b0;
		Transfer    = 1'b0;
		Ready       = 1'b0;

		case (state)
			INICIO: begin
				Clear = 1'b0; // Resetar Acumulador
			end

			SOLICITA_MEM: begin
				ReadEnable = 1'b1;
			end

			IDLE_1: begin
				ReadEnable = 1'b1;
			end

			LOAD: begin
				ReadEnable = 1'b1;
				Load       = 1'b1; // Gatilho do Reg B
			end

			ADD: begin
				Transfer = 1'b1;   // Gatilho da Soma (Reg A)
			end

			// ADDING: Nenhuma saída ativa (apenas delay)

			SAVING: begin
				WriteEnable = 1'b1; // Grava na memória
			end

			IDLE_2: begin
				Clear = 1'b0; // Reseta Acumulador para o próximo grupo
			end

			END_STATE: begin
				Ready = 1'b1;
			end
		endcase
	end

endmodule